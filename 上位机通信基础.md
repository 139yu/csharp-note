# 通信基础与RS485串口

## 1.1上位机通信接口

### 1.1.1 串口通讯

串口通信是上位机（计算机）和下位机通信常用的选择，PLC和设备通信，也会大量使用串口。想实现串口通信，在硬件上首先计算机必须要有串口硬件接口，然后设备也要有串口的预留，两者通过规定导线连接。

- 串口通讯的概念

串口通讯（Serial Communication）是指计算机和外部设备之间通过数据信号线、地线，按位进行传输数据的一种通讯方式。串口规定了接口的电气标准，没有规定使用协议。

- 串口标准划分

串口按电气标准和协议来划分，包括RS-232、RS-422、RS-485等。

### 1.1.2 以太网通信

以太网通信通常指网口通信。以太网通信速度快，而且应用非常广泛，使用TCP/IP协议。在工业控制中很多PLC都有以太网口。而且硬件设备，尤其是中高端的一般也都有网口

### 1.1.3 RS485串口通信

RS-485总线标准详细定义了总线接口的电气特性，包括两个逻辑状态的界定：当电平处于+2V至+6V之间时，代表一个逻辑状态；而当电平落在-2V至-6V范围内时，则代表另一个逻辑状态。此外，该标准采用差分传输方式来传递数字信号，这一方式能有效降低噪声信号的干扰。

![image.png](assets/1718110787301-74a4cab8-5b27-4562-b10d-86e519b82e1a.webp)

**RS485串口特点：**

1. 通讯距离长：RS485串口的抗干扰能力非常强，可以达到上千米（距离越长，传输速度越慢）
2. 半双工通信：RS485通常采用两线制。以半双工方式工作，也就是收发不能同时进行
3. 以主多从通信：RS485在统一总线上最多可以接32个节点（从设备），实现一主多从

**RS485接口定义**：

1. A或（+）：信号正
2. B或（-）：信号负

### 1.1.4通信模式

1. 单工：数据传输只支持数据在一个方向上传输。
2. 半双工：允许数据在两个方向上传输，但某一时刻只允许数据在一个方向上传输，实际上是一种切换方向的单工通信，不需要独立的接收端和发送端，两者可合并为一个端口。
3. 全双工：允许数据同时在两个方向上传输，因此全双工通信是两个单工方式的结合，需要独立的接收端和发送端。

### 1.1.5 常见的串行通信接口

![image.png](assets/1718110319013-916ae8c4-5b80-4874-8d41-1d70cca431af.webp)

UART (通用异步收发传输器），英文 Universal Asynchronous Receiver/Transmitter，简称 UART，是异步串行通信接口（串口）的总称，包括 RS232、RS499、RS422 和 RS485 等接口标准规范和总线标准规范。

## 1.2 串口通信原理和数据格式

### 1.2.1 通信原理和要求

通信原理：串行通信方式是将字节（byte）拆分成一个接一个的位（bit）后，再传输出去，收到数据的一方，再将这些位组合成原来的字节。

通信要求：传输格式必须统一，传输方式（节拍/速度）必须一致。

### 1.2.3 通信数据格式和参数

**单字节协议传输过程：**

![image-20250519204603207](assets/image-20250519204603207.png)

#### 通信参数

1. 波特率：表示每秒传的位（单位是bit）的个数。也就是每秒传输0和1的个数。常见波特率：4800b/s、9600b/s、19200b/s、38400b/s、115200b/s
2. 起始位：通常用0表示，位于字符帧开头
3. 数据位：通常包括5~8位数据。在起始位置之后，先发送低位，后发送高位。
4. 奇偶校验位：依赖校验数据传输过程中是否有错位，只占1位。奇偶校验包括：偶校验（O）；奇校验（E）；无校验（N）。现在通常都选N，因为抗干扰能力很强了。
5. 停止位：通常用1表示，编译接收端确定下一帧数据的起始位。

通常设置（9600，N，8，1）。

## 1.3 Modbus通信协议

串行通信格式表示一个字节的传输协议（9600，N，8，1），实际应用中数据传送都是几多个串行字节组合到一起。

那么如何识别多个字节？也就是多个串行字节传输和解析的标准怎么规定？

Modbus协议就是这个作用，它规定了多个字节传输的规范。

Modbus就是如何用串口一次连续传输多个有序字节的协议，它规定了一次发送多少个字节，以及字节顺序如何排列。

### 1.3.1 Modbus报文格式

Modbus支持三种传输模式：

1. RTU模式：（Remote Terminal Unit）远程终端单元模式通信，针对通信距离较长和工业现场环境恶劣而设计的通信接口。
2. TCP模式：通过以太网和互联网连接传输数据使用的是TCP/IP协议，称为TCP模式。硬件接口就是以太网接口，TCP模式也是通信的重点。
3. ASCII模式：MG标准信息交换码（0-9，a-z，A-Z），数据中每8个位的字节都用ASCII码发送，用的很少。

所有 Modbus 通信基于 **主从请求-响应模型**，报文由以下部分组成：

| **组成部分** |                      描述                      |
| :----------: | :--------------------------------------------: |
|  **地址域**  |  标识从站设备（RTU/ASCII）或 TCP 会话（TCP）   |
|  **功能码**  |   1字节，指示操作类型（如读寄存器、写线圈）    |
|  **数据域**  |        可变长度，包含请求参数或响应数据        |
|  **校验域**  | 错误检测（RTU用CRC-16，ASCII用LRC，TCP无校验） |

#### **1.3.1.1Modbus RTU 报文格式**

##### 读寄存器消息帧格式 - 0x03、0x04

**请求报文：**

| 字段         | 字节数 | 描述                             |
| ------------ | ------ | -------------------------------- |
| 从站地址     | 1      | 1-247（0为广播地址）             |
| 功能码       | 1      | 操作类型（如 0x03=读保持寄存器） |
| 起始地址高位 | 1      | 起始寄存器地址的高字节           |
| 起始地址低位 | 1      | 起始地址低字节                   |
| 读取长度高位 | 1      |                                  |
| 读取长度低位 | 1      |                                  |
| CRC16        | 2      | 校验码（小端序）                 |

**响应报文：**

| 字段      | 字节数 | 描述                                                         |
| --------- | ------ | ------------------------------------------------------------ |
| 从站地址  | 1      |                                                              |
| 功能码    | 1      | 0x04                                                         |
| 字节数    | 1      | 后续数据的总字节数，不包含CRC校验（10个寄存器×2字节=20=0x14） |
| 寄存器值1 | 2      | 大端序，可以有多个值                                         |
| 寄存器值2 | 2      |                                                              |
| ....      |        |                                                              |
| CRC16     | 2      |                                                              |

##### 写单寄存器消息帧格式 – 0x06

**请求报文与响应报文相同：**

| 字段     | 字节数 | 描述   |
| -------- | ------ | ------ |
| 从站地址 | 1      |        |
| 功能码   | 1      | 0x60   |
| 写入地址 | 2      | 大端序 |
| 写入值   | 2      | 大端序 |
| CRC16    | 2      | 小端序 |

##### 写多寄存器消息帧格式 – 0x10

**请求报文：**

| 字段      | 字节数 | 描述                                        |
| --------- | ------ | ------------------------------------------- |
| 从站地址  | 1      |                                             |
| 功能码    | 1      | 0x10                                        |
| 写入地址  | 2      | 大端序                                      |
| 写入数量  | 2      | 大端序                                      |
| 字节数    | 1      | 后续数据的总字节数，不包含CRC（写入数量×2） |
| 寄存器值1 | 2      | 写入属性是多少，寄存器值就有多少个          |
| 寄存器值2 | 2      |                                             |
| ....      |        |                                             |
| CRC16     | 2      | 小端序                                      |

**响应报文：**

| 字段     | 字节数 | 描述 |
| -------- | ------ | ---- |
| 从站地址 | 1      |      |
| 功能码   | 1      | 0x10 |
| 写入地址 | 2      |      |
| 写入数量 | 2      |      |
| CRC16    | 2      |      |

读写线圈的报文格式相同，只是功能码不一样。

##### 写单个线圈状态消息帧格式 - 0x05

**请求报文：**

| 字段     | 字节数 | 描述                           |
| -------- | ------ | ------------------------------ |
| 从站地址 | 1字节  | 目标设备地址                   |
| 功能码   | 1字节  | 0x05，写单个线圈操作码         |
| 起始地址 | 2字节  |                                |
| 写入值   | 2字节  | ON=FF00, OFF=0000 (其他值非法) |
| CRC校验  | 2字节  |                                |

**响应报文：**

| 字段     | 字节数 | 描述                   |
| -------- | ------ | ---------------------- |
| 从站地址 | 1字节  | 目标设备地址           |
| 功能码   | 1字节  | 0x05，写单个线圈操作码 |
| 起始地址 | 2字节  | 同请求                 |
| 写入值   | 2字节  | 同请求                 |
| CRC校验  | 2字节  |                        |

##### 写多个线圈状态消息帧格式 - 0x0F

**请求报文：**

| 字段     | 字节数 | 描述                                                     |
| -------- | ------ | -------------------------------------------------------- |
| 从站地址 | 1字节  | 目标设备地址                                             |
| 功能码   | 1字节  | 0x0F，写单个线圈操作码                                   |
| 起始地址 | 2字节  |                                                          |
| 线圈数量 | 2字节  |                                                          |
| 字节计数 | 1字节  | 后续数据域的字节数（=线圈数量÷8向上取整）                |
| 写入值   | N字节  | 线圈状态打包数据（**低位优先**：字节内bit0对应起始地址） |
| CRC校验  | 2字节  |                                                          |

**响应报文：**

| 字段     | 字节数 | 描述                   |
| -------- | ------ | ---------------------- |
| 从站地址 | 1字节  | 目标设备地址           |
| 功能码   | 1字节  | 0x0F，写单个线圈操作码 |
| 起始地址 | 2字节  | 同请求                 |
| 线圈数量 | 2字节  | 同请求                 |
| CRC校验  | 2字节  |                        |

#### 1.3.1.2Modbus TCP 报文格式

##### 请求报文：

|      字段      | 字节数 |                             描述                             |
| :------------: | :----: | :----------------------------------------------------------: |
| **事务标识符** | 2 字节 |       用于匹配请求与响应，每次请求递增（客户端生成）。       |
| **协议标识符** | 2 字节 |             固定为 `0x0000`，表示 Modbus 协议。              |
|  **长度字段**  | 2 字节 |        表示后续字节总数（从单元标识符到 PDU 结束）。         |
| **单元标识符** | 1 字节 | 标识从站设备地址（通常为 `0x00` 或 `0xFF`，取决于网络配置）。 |
| **Modbus PDU** | N 字节 | 包含功能码和数据（与 Modbus RTU 的 PDU 一致）。功能码+ 数据，无需CRC校验 |

##### 响应报文：

|      字段      | 字节数 |                             描述                             |
| :------------: | :----: | :----------------------------------------------------------: |
| **事务标识符** |   2    |           必须与请求报文一致，用于匹配请求与响应。           |
| **协议标识符** |   2    |             固定为 `0x0000`，表示 Modbus 协议。              |
|  **长度字段**  |   2    |            后续字节总数（单元标识符 + PDU 长度）             |
| **单元标识符** |   1    |             通常与请求报文一致（标识从站设备）。             |
| **Modbus PDU** | N 字节 | 包含功能码和数据（与 Modbus RTU 的 PDU 一致）。功能码+ 数据，无需CRC校验 |

#### 1.3.1.3Modbus ASCII 报文格式

##### 请求报文：

|     字段     | 字节数 |                  描述                  |
| :----------: | :----: | :------------------------------------: |
|    起始符    | 1 字节 |  固定为 `:`（冒号，ASCII 码 `0x3A`）   |
|    地址域    | 1 字节 |                从站地址                |
|    功能码    | 1 字节 |                                        |
| 起始地址高位 | 1 字节 |                                        |
| 起始地址低位 | 1 字节 |                                        |
| 读取长度高位 | 1 字节 |                                        |
| 读取长度低位 | 1 字节 |                                        |
|     LRC      | 1 字节 |       从地址到数据域最后一个字节       |
|    结束符    | 1 字节 | 固定位回车换行符，ASCII 码 `0x0D 0x0A` |

### 1.3.1 Modbus数据储存区和功能码

#### 一、线圈的概念

在电气控制中，接触器和中间继电器都是靠得电和失电来控制触点闭合（1）和断开（0），实现两种状态。所以，用线圈表示布尔量（1/0）。因此在协议中，针对硬件设备这两种状态的储存区就用线圈这个概念来表示。

#### 二、寄存器概念

在硬件的储存区中用来储存非布尔量的数据，就用寄存器。读写类型和特点：以西门子PLC为离谱，I和Q都表示线圈，但是它们的分工是不同的，I表示输入，输入意味着该储存区里的值必须由外部设备接入，是只读的。Q表示输出，输出表示输出结果给外部设备，是可读可写的。所以按照这个方法划分后，输入、输出线圈，输入、输出寄存器就构成了储存区的四种类型，如下表示寄存器和协议使用地址对照：

| 读写 | 储存类型 | 储存区名称 | 代号 | 简称 | 寄存器设备地址 | Modbus协议地址 |
| ---- | -------- | ---------- | ---- | ---- | -------------- | -------------- |
| 只读 | 线圈     | 输入线圈   | 1区  | 1x   | 10001-19999    | 0000H-FFFFH    |
| 读写 | 线圈     | 输出线圈   | 0区  | 0x   | 00001-09999    | 0000H-FFFFH    |
| 只读 | 寄存器   | 输入寄存器 | 3区  | 3x   | 30001-39999    | 0000H-FFFFH    |
| 读写 | 寄存器   | 输出寄存器 | 4区  | 4x   | 40001-49999    | 0000H-FFFFH    |

寄存器设备地址：一般采用10进制，通常是5位，第一位表示寄存器类型。

Modbus协议地址：指通信是使用的寄存器寻址地址。注意设备地址是40001对应寻址地址就是0x0000（16进制）；40002对应0x0001。

#### 三、功能码

功能码用来表示对不同的储存区域、执行不同的读写操作。读写两种操作，储存区4个，但是输入线圈和寄存器只能读，不能写，除去这两种，会有6个不同的操作。最后对写入操作又做了4中细分，因此形成8中常见的具体操作。如下所示：

| 功能码 | 名称                    | 功能                                                         |
| ------ | ----------------------- | ------------------------------------------------------------ |
| 01     | 读线圈状态              | 读位（读N个bit）---读从机线圈寄存器，位操作                  |
| 02     | 读输入离散量            | 读位（读N个bit）---读离散输入寄存器，位操作                  |
| 03     | 读多个保持型寄存器      | 读整型、字符型、状态字、浮点型（读N个words）---读保持寄存器，字节操作 |
| 04     | 读多个输入寄存器        | 读整型、状态字、浮点型（读N个words）---读输入寄存器，字节操作 |
| 05     | 写单个线圈              | 写位（写一个bit）---写线圈寄存器，位操作                     |
| 06     | 写单个保持寄存器        | 写整型、字符型、状态字、浮点型（写一个word）---写保持寄存器，字节操作 |
| 07     | 读取异常状态            | 取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定，用户逻辑可以将这些线圈定义，以说明从机状态，短报文适宜于迅速读取状态 |
| 08     | 回送诊断校验            | 把诊断校验报文送从机，以对通信处理进行评鉴                   |
| 09     | 编程（只用于484）       | 使主机模拟编程器作用，修改PC从机逻辑                         |
| 0A     | 控询（只用于484）       | 可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送 |
| 0B     | 读取事件计数            | 可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时 |
| 0C     | 读取通讯事件记录        | 可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误 |
| 0D     | 编程（184/384/484/584） | 可使主机模拟编程器功能修改PC从机逻辑                         |
| 0E     | 探询（184/384/484/584） | 可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送 |
| 0F     | 写多个线圈              | 可以写多个线圈---强置一串连续逻辑线圈的通断                  |
| 10     | 写多个保持寄存器        | 写多个保持寄存器---把具体的二进制值装入一串连续的保持寄存器  |
| 11     | 报告从机标识            | 可使主机判断编址从机的类型及该从机运行指示灯的状态           |
| 12     | （884和MICRO84）        | 可使主机模拟编程功能，修改PC状态逻辑                         |
| 13     | 重置通信链路            | 发生非可修改错误后，是从机复位于已知状态，可重置顺序字节     |
| 14     | 读取通用参数（584L）    | 显示扩展存储文件中的数据信息                                 |
| 15     | 写入通用参数（584L）    | 把通用参数写入扩展存储文件                                   |
| 16~40  | 保留做扩展功能备用      |                                                              |
| 41~48  | 保留以备用户功能所用    | 留作用户功能的扩展编码                                       |
| 49~77  | 非法功能                |                                                              |
| 78~7F  | 保留                    | 留作内部作用                                                 |
| 80~FF  | 保留                    | 用于异常应答                                                 |

##### 协议异常处理

功能码的高位是1，说明请求出现了异常（1000 0001：非法功能）。

| 代码 | 名称                 | 含义                                                         |
| ---- | -------------------- | ------------------------------------------------------------ |
| 01   | 非法功能             | 对于服务器(或从站)来说，询问中接收到的功能码是不可允许的操作。这也许是因为功能码仅仅适用于新设备而在被选单元中是不可实现的。同时，还指出服务器(或从站)在错误状态中处理这种请求，例如：因为它是未配置的，并且要求返回寄存器值。 |
| 02   | 非法数据地址         | 对于服务器(或从站)来说，询问中接收到的数据地址是不可允许的地址。特别是，参考号和传输长度的组合是无效的。对于带有100 个寄存器的控制器来说，带有偏移量96 和长度4的请求会成功，带有偏移量96和长度5的请求将产生异常码02。 |
| 03   | 非法数据值           | 对于服务器(或从站)来说，询问中包括的值是不可允许的值。这个值指示了组合请求剩余结构中的故障，例如：隐含长度是不正确的。并不意味着，因为MODBUS 协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。 |
| 04   | 从站设备故障         | 当服务器(或从站)正在设法执行请求的操作时，产生不可重新获得的差错。 |
| 05   | 确认                 | 与编程命令一起使用。服务器(或从站)已经接受请求，并切正在处理这个请求，但是需要长的持续时间进行这些操作。返回这个响应防止在客户机(或主站)中发生超时错误。客户机(或主站)可以继续发送轮询程序完成报文来确定是否完成处理。 |
| 06   | 从属设备忙           | 与编程命令一起使用。服务器(或从站)正在处理长持续时间的程序命令。张服务器(或从站)空闲时，用户(或主站)应该稍后重新传输报文。 |
| 08   | 存储奇偶性差错       | 与功能码20和21 以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器(或从站)设法读取记录文件，但是在存储器中发现一个奇偶校验错误。客户机(或主方)可以重新发送请求，但可以在服务器(或从站)设备上要求服务。 |
| 0A   | 不可用网关路径       | 与网关一起使用，指示网关不能为处理请求分配输入端口至输出端口的内部通信路径。通常意味着网关是错误配置的或过载的。 |
| 0B   | 网关目标设备响应失败 | 与网关一起使用，指示没有从目标设备中获得响应。通常意味着设备未在网络中。 |

![image-20250524142154783](assets/image-20250524142154783.png)

##### 请求频率异常

请求频率异常，设备会无法响应（前提是报文格式正确）。

RTU报文请求间隔：3.5个字符时间（波特率为9600的前提下）。

一个字符 = 1个起始位+8个数据位+1个校验位 + 1停止位

3.5个字符=1000ms / 9600 * (1个起始位+8个数据位+1个校验位 + 1停止位) * 3.5 = 4.01ms。

串口线路一个时刻只能有一个数据传输，如果时间间隔设置4.01ms，从站有响应报文（主站只发不接收），那么会与发送的报文冲突。

仿真软件时间间隔并不真实，不是真正的时间间隔

##### 读写冲突问题

实际情况中，读操作可能是通过一个while死循环进行，写操作可能实在某一个不确定的时刻去写，而串口链路同一时刻只能有一个数据传输，这会产生冲突。

解决方案：定义两个队列，一个读操作队列，一个写操作队列，当有写操作时先执行写操作，写操作队列为空时再执行读操作。

## 1.5 通信工具的使用

### 1.5.1 Slave从站模拟软件

从站就是硬件设备。很多时候我们手里只有一个文档，没有硬件，那就必须按照文档先做模拟测试，模拟测试成功了，将来使用硬件也是完全一致的。

Slave软件安装完成启动后如下：

![image-20250520090318127](assets/image-20250520090318127.png)

#### 软件配置

1. 从Connection菜单中选择Connect子菜单，打开连接串口设置窗口：

   ![image-20250520090433081](assets/image-20250520090433081.png)

2. 选择Serial Port，表示当前使用串口通信

3. Serial Settings选择虚拟串口COM18-COM19，表示一对虚拟串口，如果在Slave中选择COM18-COM19，那在Poll中间就要选择COM18-COM18，因为虚拟串口就好比一个导线的两端，数据从一端传递到另一端

   ![image-20250520091033242](assets/image-20250520091033242.png)

4. 其他参数按照正常设置即可

   ![image-20250520091308018](assets/image-20250520091308018.png)

5. 点击OK，连接成功

   ![image-20250520091412060](assets/image-20250520091412060.png)

   上面的设置指示实现了从站设备和串口的模拟连接，接下来在从站模拟软件Slave中，开辟对应的**储存区**，并存放一定的数据，这样主站上位机才能读取从站的数据，实现完整的模拟。

6. 点击Setup菜单，选择Slave Definition子菜单，然后做如下设置：

   ![image-20250520091654370](assets/image-20250520091654370.png)

   - Slave ID：设备的地址，任何串口通信设备都要设置，一般在1-254之间选择。
   - Function：功能码，03表示输出寄存器
   - Address mode：地址模式，十进制或十六进制
   - Address：寄存器开始地址
   - Quantity：寄存器的数量，也就是要模拟几个寄存器。（一个寄存器=2字节）

   其他设置默认即可。点击Ok如下图所示：

   ![image-20250520092238009](assets/image-20250520092238009.png)

### 1.5.2 Poll主站模拟软件

#### 软件配置

1. 与Slave一样，先配置Connection，Serial Settings选择与Slave相对的，其他配置相同

   ![image-20250520092942889](assets/image-20250520092942889.png)

2. 连接成功，可能会提示非法地址，这时候需要配置Read/Write Definition

   ![image-20250520093159045](assets/image-20250520093159045.png)

   ![image-20250520093453367](assets/image-20250520093453367.png)

   Slave ID、Function、Address、Quantity都要和从站一致。如果Address和Quantity和从站不一致就会出现Illegal Data Address提示。

如果连接成功，从站的数据修改就会同步到Poll。

### 1.5.3 总结

1. 串口号：正确选择通信端口号（串口号），在实际硬件通信中端口号是什么就选什么，没有成对说法，成对说法只是在模拟环境下才有
2. Slave ID：必须要知道从站设备ID
3. 功能码：表示对那个寄存器执行什么样的操作
4. 寄存器开始地址：表示从哪里开始读取
5. 寄存器属性：要连续读取多少个寄存器（一个寄存器占2字节）

## 1.6 IO采集控制器使用

### 1.6.1 采集控制器各种接口说明

采集控制器集成了数字量、模拟量和串口，硬件模块逻辑图如下：

![image-20250520100021249](assets/image-20250520100021249.png)

- DO数量输出端子

  当前设备输出是基于继电器的，所以数字量输出端子输出相当于一根导线一样，直接接通或断开。如在红色公共端接入24V，那么其他四个端子可以根据逻辑输出24V；如果公共端接220V交流电，那么其他四个端子也会输出交流电，可以通过DO直接控制继电器、接触器或者开关设备

- ID数字量输入端子

  黑色公共端接入的是0V，然后其他四个端子接入的是24V，可以通过按钮、或其他传感器开关实现接入

- 电源正负极端子

  右上角两个分别接入24V正极和0V即可

- AI模拟量输入端子

  黑色公共端可以不接，其他两个是4~20ma电流输入

- 温湿度采集传感器

  这两个是集成在控制器里面的，不需要接线，获取的时候直接通过输出寄存器来获取具体数据就可以了

- Type-C接口

  直接用手机数据线插入，可以直接仿真出一个串口

- RS485接线端子

  如果想测试更多的设备和接线，通常会会将RS485的A和B和具体的硬件串口连接

### 1.6.2 采集控制器Modbus地址表

##### 数字量输入DI（1x输入线圈）

| 地址（Dec） | PLC地址 | 地址说明        |
| ----------- | ------- | --------------- |
| 0           | 10001   | DI1状态         |
| 1           | 10002   | DI2状态         |
| 2           | 10003   | DI3状态         |
| 3           | 10004   | DI4状态         |
| 4           | 10005   | DI5状态（备用） |
| 5           | 10006   | DI6状态（备用） |
| 6           | 10007   | DI7状态（备用） |
| 7           | 10008   | DI8状态（备用） |

##### 数字量输出DO（0x输出线圈）

| 地址（Dec） | PLC地址 | 地址说明        |
| ----------- | ------- | --------------- |
| 0           | 00001   | DO1状态         |
| 1           | 00002   | DO2状态         |
| 2           | 00003   | DO3状态         |
| 3           | 00004   | DO4状态         |
| 4           | 00005   | DO5状态（备用） |
| 5           | 00006   | DO6状态（备用） |
| 6           | 00007   | DO7状态（备用） |
| 7           | 00008   | DO8状态（备用） |

##### 模拟输入量AI（3x输入寄存器）

| 地址（Dec | PLC地址 | 地址说明        |
| --------- | ------- | --------------- |
| 0         | 30001   | AI1数值         |
| 1         | 30002   | AI2数值         |
| 2         | 30003   | AI3数值（备用） |
| 3         | 30004   | AI4数值（备用） |
| 4         | 30005   | AI5数值（备用） |
| 5         | 30006   | AI6数值（备用） |
| 6         | 30007   | AI7数值【备用】 |
| 7         | 30008   | AI8数值【备用】 |

##### 温湿度采集（4x保持寄存器）（需要除以10）

| 地址(Dec) | PLC地址 | 地址说明        |
| --------- | ------- | --------------- |
| 0         | 40001   | 1号温度         |
| 1         | 40002   | 1号湿度         |
| 2         | 40003   | 2号温度         |
| 3         | 40004   | 2号湿度         |
| 4         | 40005   | 3号温度【备用】 |
| 5         | 40006   | 3号湿度【备用】 |
| 6         | 40007   | 4号温度【备用】 |
| 7         | 40008   | 4号湿度【备用】 |
| 8         | 40009   | DI输入（16位）  |
| 9         | 40010   | DI输出（16位）  |
| 10        | 40011   | AI1数值         |
| 11        | 40012   | AI2数值         |
| 12        | 40013   | AI3数值         |
| 13        | 40014   | AI4数值         |
| 14        | 40015   | AI5数值         |
| 15        | 40016   | AI6数值         |
| 16        | 40017   | AI7数值         |
| 17        | 40018   | AI8数值         |
| 18        | 40019   | 从站地址        |
| 19        | 40020   | 波特率          |

##### 波特率说明

| 0    | 9600   |
| ---- | ------ |
| 1    | 14400  |
| 2    | 19200  |
| 3    | 38400  |
| 4    | 56000  |
| 5    | 57600  |
| 6    | 115200 |

# PLC仿真软件使用

## 博图使用

1. 创建项目

   ![image-20250528193419176](assets/image-20250528193419176.png)

2. 选择打开项目视图

   ![image-20250528193511393](assets/image-20250528193511393.png)

3. 双击添加新设备

   ![image-20250528193549821](assets/image-20250528193549821.png)

4. 选择设备

   ![image-20250528193620265](assets/image-20250528193620265.png)

5. 配置以太网地址，与当前设备同网段

   ![image-20250528193912290](assets/image-20250528193912290.png)

   ![image-20250528194031368](assets/image-20250528194031368.png)

6. 设置连接机制

   ![image-20250528194121903](assets/image-20250528194121903.png)

   ![image-20250528194202017](assets/image-20250528194202017.png)

7. 配置项目，编译时支持仿真

   ![image-20250528194316830](assets/image-20250528194316830.png)

   ![image-20250528194339144](assets/image-20250528194339144.png)

8. 编译

   ![image-20250528194515817](assets/image-20250528194515817.png)

9. 启动仿真

   ![image-20250528194640484](assets/image-20250528194640484.png)

10. 搜索到当前设备，然后下载、装载

    ![image-20250528194730822](assets/image-20250528194730822.png)

    ![image-20250528194801521](assets/image-20250528194801521.png)

## S7-PLCSIM Advanced V3.0使用

1. 打开控制面板，设置PG/PC接口

   ![image-20250528213234942](assets/image-20250528213234942.png)

   ![image-20250528213350046](assets/image-20250528213350046.png)

2. 打开S7-PLCSIM Advanced V3.0，生成模拟PLC

   ![image-20250528213555132](assets/image-20250528213555132.png)

   ![image-20250528214106944](assets/image-20250528214106944.png)

3. 打开博图，打开项目，选择程序块下的Main，双击

   ![image-20250528215832995](assets/image-20250528215832995.png)

4. 将此拖拽到程序段，然后直接确认

   ![image-20250528215959959](assets/image-20250528215959959.png)

   ![image-20250528220033058](assets/image-20250528220033058.png)

   ![image-20250528220112526](assets/image-20250528220112526.png)

   ![image-20250528220604921](assets/image-20250528220604921.png)

5. 编辑连接信息

   ![image-20250528220742267](assets/image-20250528220742267.png)

   ![image-20250528221026965](assets/image-20250528221026965.png)

   ![image-20250528221040913](assets/image-20250528221040913.png)

   1. InterfaceId：接口Id，按一下步骤找到填写：

      ![image-20250528221143457](assets/image-20250528221143457.png)

      ![image-20250528221236295](assets/image-20250528221236295.png)

   2. ID：从站ID，0-255任意填写

   3. ConnectionType：不需要修改

   4. ActiveEstablished：是否需要主动连接，当前为从站，不需要

   5. RemoteAddress：远程连接地址，不用修改，默认0.0.0.0

   6. RemoteAddress：远程连接端口，默认0

   7. RemotePort：当前端口，配置502

6. 设置刚才配置的连接信息

   ![image-20250528221844586](image-20250528221844586.png)

7. 编译、下载并启动

   ![image-20250528221952258](assets/image-20250528221952258.png)

   ​	![image-20250528222331956](assets/image-20250528222331956.png)

   

   

   